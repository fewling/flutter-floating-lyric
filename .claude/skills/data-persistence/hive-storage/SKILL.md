---
name: hive-storage
description: Detailed guide to Hive storage in Floating Lyric app, covering setup, type adapters, box management, CRUD operations, and best practices for persistent data storage.
license: MIT
---

# Hive Storage

This skill provides comprehensive documentation on using Hive for persistent data storage in the Floating Lyric app.

## Overview

**Hive** is a lightweight, fast, NoSQL database for Flutter/Dart. The Floating Lyric app uses Hive to store lyrics locally.

**Package**: `hive_ce_flutter` (Community Edition)

**Version**: Check [pubspec.yaml](../../../pubspec.yaml)

### Why Hive?

✅ **Fast** — Pure Dart, no native dependencies  
✅ **Lightweight** — Minimal overhead  
✅ **No SQL** — Key-value store, simple API  
✅ **Type-safe** — With type adapters  
✅ **Encrypted** — Supports encryption (optional)  
✅ **Cross-platform** — Works on all Flutter platforms  
✅ **Shared Access** — Multiple isolates can access same box

**Use Case in Floating Lyric**: Store lyrics (title, artist, content) for offline access and display in overlay.

## Setup

### Dependencies

**File**: [pubspec.yaml](../../../pubspec.yaml)

```yaml
dependencies:
  hive_ce: ^2.6.0
  hive_ce_flutter: ^2.0.0+2

dev_dependencies:
  hive_ce_generator: ^1.6.0
  build_runner: ^2.9.0
```

**Packages**:

- `hive_ce` — Core Hive library
- `hive_ce_flutter` — Flutter-specific utilities
- `hive_ce_generator` — Type adapter code generation
- `build_runner` — Code generation orchestrator

### Initialization

**File**: [lib/main.dart](../../../lib/main.dart)

```dart
Future<(SharedPreferences, Box<LrcModel>)> bootstrap() async {
  final pref = await SharedPreferences.getInstance();

  // 1. Get application directory
  final dir = await getApplicationDocumentsDirectory();

  // 2. Initialize Hive with path
  await Hive.initFlutter();

  // 3. Register type adapters
  Hive.registerAdapters();

  // 4. Open box
  final lrcModelBox = await Hive.openBox<LrcModel>('lrc', path: dir.path);

  return (pref, lrcModelBox);
}
```

**Steps**:

1. **Get path** — Use `path_provider` to get app directory
2. **Init Hive** — `Hive.initFlutter()` sets default path
3. **Register adapters** — Required for custom types
4. **Open box** — Opens or creates a box

### Type Adapters

Type adapters serialize/deserialize custom types for Hive storage.

#### Adapter Specification

**File**: [lib/hive/hive_adapters.dart](../../../lib/hive/hive_adapters.dart)

```dart
import 'package:hive_ce/hive.dart';

import '../models/lyric_model.dart';

part 'hive_adapters.g.dart';

@GenerateAdapters([AdapterSpec<LrcModel>()])
class HiveAdapters {}
```

**Annotation**: `@GenerateAdapters` — Tells `hive_ce_generator` to generate adapters

**Generated File**: `hive_adapters.g.dart`

#### Generated Registrar

**File**: [lib/hive/hive_registrar.g.dart](../../../lib/hive/hive_registrar.g.dart)

```dart
// Generated by Hive CE
// Do not modify
// Check in to version control

import 'package:hive_ce/hive.dart';
import 'package:floating_lyric/hive/hive_adapters.dart';

extension HiveRegistrar on HiveInterface {
  void registerAdapters() {
    registerAdapter(LrcModelAdapter());
  }
}

extension IsolatedHiveRegistrar on IsolatedHiveInterface {
  void registerAdapters() {
    registerAdapter(LrcModelAdapter());
  }
}
```

**Usage**:

```dart
Hive.registerAdapters(); // Registers all adapters
```

**Note**: Unlike `.g.dart` files, `hive_registrar.g.dart` should be checked into version control.

## Data Model

### LrcModel

**File**: [lib/models/lyric_model.dart](../../../lib/models/lyric_model.dart)

```dart
import 'package:freezed_annotation/freezed_annotation.dart';

part 'lyric_model.freezed.dart';
part 'lyric_model.g.dart';

@freezed
@immutable
sealed class LrcModel with _$LrcModel {
  const factory LrcModel({
    required String id,
    String? fileName,
    String? content,
    String? title,
    String? artist,
  }) = _LrcModel;

  factory LrcModel.fromJson(Map<String, dynamic> json) =>
      _$LrcModelFromJson(json);
}
```

**Fields**:

- `id` — SHA-256 hash of title + artist + content (unique identifier)
- `fileName` — Display name (e.g., "Song Title - Artist Name")
- `content` — LRC formatted lyrics
- `title` — Song title
- `artist` — Artist name

**Type**: Freezed model with JSON serialization

**Note**: Hive stores this as JSON internally (via generated adapter).

## Box Operations

### Opening a Box

```dart
final lrcBox = await Hive.openBox<LrcModel>('lrc', path: dir.path);
```

**Parameters**:

- `name` — Box name (file will be `lrc.hive`)
- `path` — Optional directory path
- Type parameter — `Box<LrcModel>` for type safety

**Returns**: `Box<LrcModel>`

### Box Types

```dart
// Typed box (recommended)
Box<LrcModel> lrcBox = await Hive.openBox<LrcModel>('lrc');

// Untyped box
Box box = await Hive.openBox('generic');
```

**Best Practice**: Always use typed boxes for type safety.

### Closing a Box

```dart
await lrcBox.close();
```

**Note**: Closing is optional; Hive auto-closes on app termination.

### Deleting a Box

```dart
await Hive.deleteBoxFromDisk('lrc');
```

**Warning**: Permanently deletes all data in the box.

## CRUD Operations

### Repository Pattern

The app uses a **repository pattern** to abstract Hive operations.

**File**: [lib/repos/persistence/local/local_db_repo.dart](../../../lib/repos/persistence/local/local_db_repo.dart)

```dart
class LocalDbRepo {
  LocalDbRepo({required Box<LrcModel> lrcBox}) : _lrcBox = lrcBox;

  final Box<LrcModel> _lrcBox;

  // READ operations
  List<LrcModel> get allRawLyrics => _lrcBox.values.toList();

  LrcModel? getLyricByID(dynamic id) => _lrcBox.get(id);

  LrcModel? getLyric(String title, String artist) =>
      _lrcBox.values.firstWhereOrNull(
        (e) =>
            (e.title == title && e.artist == artist) ||
            (e.title == artist && e.artist == title) ||
            (e.fileName == '$title - $artist') ||
            (e.fileName == '$artist - $title'),
      );

  List<LrcModel> search(String searchTerm) {
    final search = searchTerm.toLowerCase().trim();
    return _lrcBox.values
        .where(
          (e) =>
              (e.title != null && e.title!.toLowerCase().contains(search)) ||
              (e.artist != null && e.artist!.toLowerCase().contains(search)) ||
              (e.fileName != null &&
                  e.fileName!.toLowerCase().contains(search)),
        )
        .toList();
  }

  // CREATE/UPDATE operations
  Future<void> putLyric(LrcModel lrcDB) => _lrcBox.put(lrcDB.id, lrcDB);

  Future<void> updateLyric(LrcModel lrc) => _lrcBox.put(lrc.id, lrc);

  Future<void> addBatchLyrics(List<LrcModel> lyrics) async {
    final entries = {for (final lyric in lyrics) lyric.id: lyric};
    logger.i('Adding batch lyrics: ${entries.length} lyrics');

    return _lrcBox.putAll(entries).onError((error, stackTrace) {
      logger.e('Error adding batch lyrics: $error\nstacktrace: $stackTrace');
    });
  }

  // DELETE operations
  Future<void> deleteLyric(LrcModel lyric) => _lrcBox.delete(lyric.id);

  Future<int> deleteAllLyrics() => _lrcBox.clear();

  // UTILITY operations
  bool fileNameExists(String fileName) =>
      _lrcBox.values.any((e) => e.fileName == fileName);
}
```

### Create (Put)

```dart
// Single item
await _lrcBox.put(lrcDB.id, lrcDB);

// Batch insert
final entries = {
  'id1': LrcModel(...),
  'id2': LrcModel(...),
};
await _lrcBox.putAll(entries);
```

**Key**: String ID (SHA-256 hash)  
**Value**: `LrcModel` instance

**Behavior**: Overwrites if key exists, creates if not.

### Read (Get)

```dart
// By ID
LrcModel? lyric = _lrcBox.get('some-id');

// All values
List<LrcModel> allLyrics = _lrcBox.values.toList();

// Search (filter)
List<LrcModel> results = _lrcBox.values.where(
  (e) => e.title!.contains('search'),
).toList();

// First match
LrcModel? lyric = _lrcBox.values.firstWhereOrNull(
  (e) => e.title == title && e.artist == artist,
);
```

**API**:

- `box.get(key)` — Get by key
- `box.values` — Iterable of all values
- `box.keys` — Iterable of all keys
- `box.length` — Number of entries

### Update

```dart
await _lrcBox.put(lrc.id, lrc); // Same as create
```

**Note**: Hive uses the same method for create/update based on key existence.

### Delete

```dart
// Single item
await _lrcBox.delete('some-id');

// Clear all
await _lrcBox.clear();

// Multiple items
await _lrcBox.deleteAll(['id1', 'id2', 'id3']);
```

**Returns**: `Future<void>` or `Future<int>` (clear returns count)

## Service Layer

The **service layer** adds business logic on top of the repository.

**File**: [lib/services/db/local/local_db_service.dart](../../../lib/services/db/local/local_db_service.dart)

```dart
class LocalDbService {
  LocalDbService({required LocalDbRepo localDBRepo}) : _localDB = localDBRepo;

  final LocalDbRepo _localDB;

  Future<String> saveLrc({
    required String title,
    required String artist,
    String? content,
  }) async {
    // Generate unique ID
    final digest = sha256.convert(utf8.encode('$title$artist$content'));
    final id = digest.toString();

    // Create model
    final lrcDB = LrcModel(
      id: id,
      fileName: '$title - $artist',
      title: title,
      artist: artist,
      content: content,
    );

    // Save
    await _localDB.putLyric(lrcDB);
    return id;
  }

  LrcModel? getLyricById(String id) => _localDB.getLyricByID(id);

  LrcModel? getLyricBySongInfo(String title, String artist) =>
      _localDB.getLyric(title, artist);

  List<LrcModel> getAllLyrics() => _localDB.allRawLyrics;

  List<LrcModel> searchLyrics(String searchTerm) => _localDB.search(searchTerm);

  Future<void> updateLrc(LrcModel lrcDb) => _localDB.updateLyric(lrcDb);

  Future<void> deleteLrc(LrcModel lrcDb) => _localDB.deleteLyric(lrcDb);

  Future<int> deleteAllLyrics() => _localDB.deleteAllLyrics();
}
```

**Responsibilities**:

- Generate unique IDs (SHA-256)
- Format file names
- Delegate CRUD to repository

**Pattern**: Service → Repository → Hive Box

## Usage in BLoC

**File**: Example from lyric management BLoC

```dart
class LyricListBloc extends Bloc<LyricListEvent, LyricListState> {
  LyricListBloc({required LocalDbService localDbService})
      : _localDbService = localDbService {
    on<LoadLyrics>(_onLoadLyrics);
    on<DeleteLyric>(_onDeleteLyric);
    on<DeleteAllLyrics>(_onDeleteAllLyrics);
  }

  final LocalDbService _localDbService;

  Future<void> _onLoadLyrics(
    LoadLyrics event,
    Emitter<LyricListState> emit,
  ) async {
    emit(const LyricListState.loading());

    final lyrics = _localDbService.getAllLyrics();

    emit(LyricListState.loaded(lyrics: lyrics));
  }

  Future<void> _onDeleteLyric(
    DeleteLyric event,
    Emitter<LyricListState> emit,
  ) async {
    await _localDbService.deleteLrc(event.lyric);

    // Reload
    final lyrics = _localDbService.getAllLyrics();
    emit(LyricListState.loaded(lyrics: lyrics));
  }

  Future<void> _onDeleteAllLyrics(
    DeleteAllLyrics event,
    Emitter<LyricListState> emit,
  ) async {
    await _localDbService.deleteAllLyrics();

    emit(const LyricListState.loaded(lyrics: []));
  }
}
```

**Flow**: BLoC Event → Service → Repository → Hive → BLoC State

## Shared Access (Dual-App)

Both Main App and Overlay App access the **same Hive box**.

### Initialization

**File**: [lib/main.dart](../../../lib/main.dart)

```dart
// Main App
Future<void> main() async {
  final (pref, lrcModelBox) = await bootstrap(); // Opens box
  runApp(MainApp(pref: pref, lrcBox: lrcModelBox));
}

// Overlay App
@pragma('vm:entry-point')
Future<void> overlayView() async {
  final (pref, lrcModelBox) = await bootstrap(); // Opens same box
  runApp(OverlayApp(lrcBox: lrcModelBox));
}

// Shared bootstrap
Future<(SharedPreferences, Box<LrcModel>)> bootstrap() async {
  final pref = await SharedPreferences.getInstance();
  final dir = await getApplicationDocumentsDirectory();
  await Hive.initFlutter();
  Hive.registerAdapters();
  final lrcModelBox = await Hive.openBox<LrcModel>('lrc', path: dir.path);
  return (pref, lrcModelBox);
}
```

**Key Points**:

- Same box name (`'lrc'`)
- Same path (`dir.path`)
- Both apps can read/write
- Hive handles concurrent access

### Access Patterns

**Main App**:

- **Write-heavy** — Add, edit, delete lyrics
- **Full CRUD** — Complete management

**Overlay App**:

- **Read-heavy** — Fetch lyrics for display
- **Minimal writes** — Rare updates (if any)

**Best Practice**: Main app owns data mutations, overlay reads.

## Code Generation

### Generate Type Adapters

```bash
fvm dart run build_runner build -d
```

**Generates**:

- `hive_adapters.g.dart` — Type adapter implementations
- `hive_registrar.g.dart` — Adapter registration extension

**Watch Mode**:

```bash
fvm dart run build_runner watch -d
```

**See**: [Code Generation - Build Commands](../../code-generation/build-commands/SKILL.md)

## Best Practices

### 1. Use Repositories

Always abstract Hive access behind repositories:

```dart
// ✅ Good
class LocalDbRepo {
  final Box<LrcModel> _lrcBox;

  LrcModel? getLyric(String id) => _lrcBox.get(id);
}

// ❌ Bad (direct access in BLoC)
class MyBloc extends Bloc<MyEvent, MyState> {
  final Box<LrcModel> lrcBox;

  void _onEvent(MyEvent event, Emitter emit) {
    final lyric = lrcBox.get(event.id); // Direct box access
  }
}
```

**Why**: Testability, abstraction, easier to mock.

### 2. Type-Safe Boxes

Always use typed boxes:

```dart
// ✅ Good
Box<LrcModel> lrcBox = await Hive.openBox<LrcModel>('lrc');

// ❌ Bad
Box box = await Hive.openBox('lrc');
```

**Why**: Compile-time type safety, IDE autocomplete.

### 3. Unique Keys

Use unique, deterministic keys:

```dart
// ✅ Good (SHA-256 hash)
final digest = sha256.convert(utf8.encode('$title$artist$content'));
final id = digest.toString();

// ❌ Bad (random)
final id = Random().nextInt(1000).toString(); // Collisions!

// ❌ Bad (timestamp)
final id = DateTime.now().millisecondsSinceEpoch.toString(); // Not deterministic
```

**Why**: Prevents duplicates, consistent across app restarts.

### 4. Error Handling

Wrap Hive operations in try-catch:

```dart
Future<void> putLyric(LrcModel lrcDB) async {
  try {
    await _lrcBox.put(lrcDB.id, lrcDB);
  } catch (e, stackTrace) {
    logger.e('Error putting lyric: $e\n$stackTrace');
    rethrow; // Let BLoC handle
  }
}
```

**Why**: Database operations can fail (disk full, permissions, etc.).

### 5. Lazy Boxes for Large Data

If storing large objects, use lazy boxes:

```dart
final lazyBox = await Hive.openLazyBox<LrcModel>('lrc');
final lyric = await lazyBox.get('some-id'); // Async read
```

**Why**: Loads values on-demand, saves memory.

**Note**: Current app uses regular boxes (fine for lyric size).

### 6. Encryption (Optional)

For sensitive data, use encryption:

```dart
import 'package:hive_ce/hive.dart';

final encryptionKey = Hive.generateSecureKey();
final encryptedBox = await Hive.openBox<LrcModel>(
  'lrc',
  encryptionCipher: HiveAesCipher(encryptionKey),
);
```

**Note**: Store `encryptionKey` securely (e.g., `flutter_secure_storage`).

### 7. Box Compaction

Hive auto-compacts, but you can trigger manually:

```dart
await lrcBox.compact();
```

**When**: After many deletes, to reclaim disk space.

## Common Pitfalls

### 1. Forgetting to Register Adapters

**Problem**: `HiveError: Cannot find TypeAdapter for MyModel`

**Solution**: Call `Hive.registerAdapters()` before opening box

```dart
await Hive.initFlutter();
Hive.registerAdapters(); // ← Don't forget!
final box = await Hive.openBox<LrcModel>('lrc');
```

### 2. Circular References

**Problem**: Models with circular references crash Hive

**Solution**: Avoid circular references, or use lazy properties

```dart
// ❌ Bad
class User {
  List<Post> posts; // Post references User, User references Posts
}

// ✅ Good
class User {
  List<String> postIds; // Store IDs instead
}
```

### 3. Mutating Values Directly

**Problem**: Changes not persisted

```dart
final lyric = lrcBox.get('some-id');
lyric.title = 'New Title'; // ❌ Not saved!
```

**Solution**: Use `put` after mutation (or use immutable models)

```dart
final lyric = lrcBox.get('some-id');
final updated = lyric.copyWith(title: 'New Title');
await lrcBox.put(updated.id, updated); // ✅ Saved
```

**Note**: Freezed models enforce immutability, preventing this issue.

### 4. Opening Box Multiple Times

**Problem**: Performance overhead, potential conflicts

```dart
// ❌ Bad
final box1 = await Hive.openBox<LrcModel>('lrc');
final box2 = await Hive.openBox<LrcModel>('lrc'); // Reopens same box
```

**Solution**: Open once, pass to dependencies

```dart
// ✅ Good
final lrcBox = await Hive.openBox<LrcModel>('lrc');
final repo = LocalDbRepo(lrcBox: lrcBox);
```

### 5. Not Closing Boxes (Usually OK)

**Problem**: Rare data corruption if app crashes during write

**Solution**: Hive auto-closes on app termination; manual close optional

```dart
// Optional in dispose
await lrcBox.close();
```

**Note**: In practice, auto-close is fine for most apps.

## Debugging

### Inspect Box Contents

```dart
// Print all keys
print('Keys: ${lrcBox.keys.toList()}');

// Print all values
for (final lyric in lrcBox.values) {
  print('${lyric.title} - ${lyric.artist}');
}

// Check box size
print('Box length: ${lrcBox.length}');
```

### Hive Location

**macOS/iOS Simulator**:

```
~/Library/Containers/<bundle-id>/Data/Documents/lrc.hive
```

**Android Emulator**:

```
/data/data/<package-name>/app_flutter/lrc.hive
```

**Inspect with Tool**:
Use Hive Studio or custom script to read `.hive` files.

### Clear Box (Development)

```dart
await Hive.deleteBoxFromDisk('lrc');
```

**Warning**: Deletes all data permanently.

## Performance Considerations

### Read Performance

✅ **Fast** — Hive reads are in-memory after box open  
✅ **Indexed** — Use `box.get(key)` for O(1) lookup  
✅ **Lazy** — Use lazy boxes for large datasets

### Write Performance

✅ **Fast** — Optimized for small writes  
⚠️ **Batch** — Use `putAll` for bulk inserts (faster than multiple `put`)

```dart
// ✅ Fast
await lrcBox.putAll({
  'id1': lyric1,
  'id2': lyric2,
  'id3': lyric3,
});

// ❌ Slow
await lrcBox.put('id1', lyric1);
await lrcBox.put('id2', lyric2);
await lrcBox.put('id3', lyric3);
```

### Memory Usage

- **Regular Box** — All values in memory (fine for small datasets)
- **Lazy Box** — Load on-demand (use for large datasets)

**Floating Lyric**: Regular box is fine (lyrics are small, ~100 entries max).

## Testing

### Unit Testing Repositories

```dart
import 'package:hive_ce/hive.dart';
import 'package:hive_test/hive_test.dart'; // Test utilities

void main() {
  setUp(() async {
    await setUpTestHive(); // Setup in-memory Hive
  });

  tearDown(() async {
    await tearDownTestHive(); // Cleanup
  });

  test('LocalDbRepo can save and retrieve lyric', () async {
    final box = await Hive.openBox<LrcModel>('test');
    final repo = LocalDbRepo(lrcBox: box);

    final lyric = LrcModel(
      id: '123',
      title: 'Test Song',
      artist: 'Test Artist',
    );

    await repo.putLyric(lyric);

    final retrieved = repo.getLyricByID('123');
    expect(retrieved, lyric);
  });
}
```

### Mocking in BLoC Tests

Use `mocktail` to mock repositories:

```dart
class MockLocalDbRepo extends Mock implements LocalDbRepo {}

void main() {
  late MockLocalDbRepo mockRepo;
  late MyBloc bloc;

  setUp(() {
    mockRepo = MockLocalDbRepo();
    bloc = MyBloc(repo: mockRepo);
  });

  test('emits loaded state when lyrics fetched', () {
    when(() => mockRepo.allRawLyrics).thenReturn([testLyric]);

    bloc.add(const LoadLyrics());

    expectLater(
      bloc.stream,
      emits(LyricListState.loaded(lyrics: [testLyric])),
    );
  });
}
```

## Related Skills

- [Repository Pattern](../../architecture/repository-pattern/SKILL.md) — Data layer architecture
- [Code Generation - Build Commands](../../code-generation/build-commands/SKILL.md) — Generate adapters
- [Dual-App Pattern](../../architecture/dual-app-pattern/SKILL.md) — Shared Hive access
- [State Management](../../state-management/SKILL.md) — Using Hive data in BLoCs

## Summary

Hive storage in Floating Lyric:

- ✅ **Type-safe** — Generated adapters for `LrcModel`
- ✅ **Shared** — Both apps access same box
- ✅ **Repository pattern** — Abstract Hive behind repo/service layers
- ✅ **Immutable models** — Freezed prevents mutation bugs
- ✅ **Code generation** — `build_runner` generates adapters
- ✅ **Fast & lightweight** — Perfect for local lyric storage

**Key Files**:

- [lib/hive/hive_adapters.dart](../../../lib/hive/hive_adapters.dart) — Adapter spec
- [lib/repos/persistence/local/local_db_repo.dart](../../../lib/repos/persistence/local/local_db_repo.dart) — Repository
- [lib/services/db/local/local_db_service.dart](../../../lib/services/db/local/local_db_service.dart) — Service
- [lib/models/lyric_model.dart](../../../lib/models/lyric_model.dart) — Data model
